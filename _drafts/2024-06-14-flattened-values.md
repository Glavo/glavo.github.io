---
title: 'flattened-values'
date: 2024-06-14 19:05:19
tags:
  - JVM
  - Valhalla
categories: translate
description: ''
---

原文链接：[encodings for flattened heap values](https://cr.openjdk.org/~jrose/values/flattened-values.html#requirements)

---

Project Valhalla 的一个关键目标是将值对象展平至其堆容器中，同时维持这些容器所有规定的行为。值的展平表示必须为值的每个字段提供存储位，并直接在容器中分配（或至少可以间接访问）；当容器允许存储 `null` 时，它也必须可以表示 `null`。如果读写容器时线程间发生数据争用，那么容器通常还必须保证一致性。

本文档讨论了此类堆容器的多种实现方案。我们特别关注了展平值存储的一种常见但麻烦的场景，其中容器被组织为不大于 64bit（或者可能是 126bit）的单个机器字。

我们将考虑在容器中引入 *null 通道*的方法，以便在必须将空引用（逻辑上）存储到容器中时表示空引用。这个 null 通道可能在机器字内部，也可能需要在机器字外有额外的字节。

## 必要条件

在我们考虑“是什么”之前，我们必须定义“为什么”，即我们的实现将满足的要求。这需要我们定义一些术语。

### 什么是容器？

Java 变量可以是堆对象中的字段，也可以是堆数组中的元素；这些都是可能的堆变量。还有一些非堆变量：它们是局部变量或者线程栈上 activation frame 中的栈元素。

*容器（container）*只是 Java 语言或 JVM 所定义的变量的实现。那么为什么不直接说“变量”呢？因为“容器”一词更侧重于变量低级、具体的实现特征，而不是其逻辑上被指定的行为。值得注意的是，所有 Java 和 VM 变量（除了 `int` 这样的基本类型的变量）都被指定为引用，并且必须表现出引用的行为。除非有特殊约定，否则这些变量都将被初始化为 null，并作为指针被读写。如果它们的类型是基于值的类（或者 Valhalla 值），即使在竞态条件下，their successive values are observed to behave with full consistency。


虽然他的逻辑上的行为使变量看起来像只包含对一系列连续分配的对象（和 null）的单个引用，但 Valhalla 允许将变量下的容器展平。尽管它的行为类似于指针，但它的格式类似于 `int` 变量。如果值有多个字段，它的行为就像多个变量（`int`、引用或者其他变量）；这些变量彼此相邻存储，并且都存储在扁平化的容器中。容器还可以采用一种策略来表示逻辑上存在的空引用，即使容器物理上根本没有引用。

> 在 Valhalla 之前，每个变量的逻辑特性及其类型或多或少直接决定了容器的物理结构。（但也有例外，比如将堆对象重组到线程寄存器中的标量优化。）这就是为什么“容器”一词主要在 Valhalla 背景下有用。

对于非堆容器的实现我们就不多说了，因为它们是有 JIT 代码或者解释器所管理的。幸运的是，它们从不受竞态条件的约束，因为这样的容器只由创建它的线程使用。你可以把一个值的非堆容器想象成几个机器寄存器或线程堆栈位置，通常彼此之间不相邻。

位于堆中意味着容器位于 Java 堆上的封闭存储块、对象或数组中。通常存储块的 identity 是动态计算的。（静态字段是一个例外，它们所包含的块是恒定的。）但是块中的容器必须具有相对于块可预测的位置。他还必须具有可预测的、静态定义的格式，允许从多个线程中运行的多个代码位置有效地访问该值。与格式相关的（对于任何给定的容器）是访问方法，也就是将值对象（或 null）写入或读出（或 CAS）堆容器的过程。

> 堆位置是动态计算的。除静态字段外，任何给定的访问都可能是对许多动态选择的包围对象或数组中的一个的访问。