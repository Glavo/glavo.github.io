---
title: 'Java 值对象的布局'
date: 2024-06-15 10:37:14
tags:
  - JVM
  - Valhalla
categories: blog
description: 'Java 值对象的布局'
---

OpenJDK 的 Project Valhalla 正在将值类型引入 Java，通过允许用户声明值类（value class），使 JVM 能够更自由的排布对象。这篇文章将会介绍值对象的内存布局。

## 值类

在介绍值对象的布局之前，先让我快速给介绍一下 Valhalla 中的值类。如果你对 Valhalla 已经有所了解，可以跳过这一小节。

Valhalla 中的值类是以 `value` 这个上下文关键字所修饰的类：

```java
public value class MyClass {
  // ...
}
```

值类的实例就是值对象，它们的主要特点在于：

* 所有字段都必须是 `final` 的；
* 不支持通过 `synchronized` 对值对象进行加锁；
* `==` 对于值对象来说不再是比较引用，而是递归的对于所有字段应用 `==`；
* `System.identityHashCode` 对于值对象会基于它的字段进行计算，字段值完全相同的值对象的 `identityHashCode` 也完全一致；
* 无法对它们使用 `java.lang.ref` 包中的工具（比如 `WeakReference`）。

因为这些特点，JVM 能够更自由的排布对象，减少装箱，从而优化性能内存占用。

## 主要难题

在 JVM 为值对象优化内存布局时，有两个问题我们需要特别考虑：一致性和空引用（`null`）。

### 一致性

看看这段代码：

```java
record Pair(long v0, long v1) {}

class MyClass {
    Pair pair = new Pair(0L, 0L);
}

var c = new MyClass();
new Thread(() -> c.pair = new Pair(10L, 20L)).start();
System.out.println("c.pair = " + c.pair);

```

上面的代码中，`Pair` 拥有两个字段，但即便是在另一个线程中修改 `MyClass.pair` 这个字段，我们也能保证它要么是 `[0, 0]`，要么是 `[10, 20]`。

对于引用类型来说，这是自然而然的，毕竟 `MyClass.pair` 这个字段只是一个引用，或者说是一个指针。我们先在线程本地构造了一个包含新值的对象，这一步不涉及多线程，非常安全；随后我们去更新 `MyClass.pair` 这个字段中存储的指针值，这个过程是原子的，另一个线程中观察到的要么是旧对象的地址，要么是新对象的地址，不可能出现一个损坏的对象，所以也很安全。

但是如果 `Pair` 是一个值类型，那么这件事就不这么简单了。

如果 `Pair` 是值类型，那么我们可能会期望上面的代码被优化成这样：

```java
class MyClass {
    long pair$v0 = 0L;
    long pair$v1 = 0L;
}

var c = new MyClass();
new Thread(() -> { 
    c.pair$v0 = 10L;
    c.pair$v1 = 10L;
}).start();
System.out.println("c.pair = " + c.pair);
```

但如果真的这样实现那问题就来了，因为给 `c.pair$v0` 和 `c.pair$v1` 的赋值变成了两步。假如我们刚好在 `c.pair$v0 = 10L` 与 `c.pair$v1 = 10L` 这两句之间去观察 `c.pair`，那么它的值就可能是 `[10, 0]`，这里就发生了字段撕裂，破坏了一致性。

这乍一看不是什么大问题，但仔细一想，我们从没有调用过 `new Pair(10, 0)`，这个 `[10, 0]` 是绕过构造函数凭空被创造而出的，这就是个大问题了。如果我们在构造函数里对参数值进行检查以保证安全，那么字段撕裂就可能绕过安全检查构造出非法值，这是无法接受的。

对于 Valhalla 的值类型，JVM 默认也会通过一些额外的手段维护一致性，同时它允许你标注特定类型放弃一致性，从而让 JVM 能够进一步优化它。

### 空引用

Java 目前所有引用类型的变量/字段/数组元素都支持空引用（`null`）。

Valhalla 的值类型支持空引用，原有的使用了 `null` 的代码不需任何更改也能享受到值类型的改进，JVM 通过**空通道（null channel）**来支持此这种功能；Valhalla 也允许将值类型标记为不可空类型，此时 JVM 无需考虑 `null`，能够更自由地处理值类型。

## 布局方案

位于堆上的值对象可能是另一个对象的字段成员，也可能是数组中的元素，我们在这里要考虑的是这些值对象是如何嵌入它的父级（也就是包含值对象字段的对象，或者元素是值对象的数组）的。

这一节会简单介绍基本的值对象布局，而它们如何支持 `null`、如何维护一致性等高级细节会在后面几节中阐述。

### 无头对象

对于这样一个普通的 Java 类：

```java
class MyClass {
    private T0 field0;
    private T1 field1;
    private T2 field2;
    
    // ...
}
```

它的实例的内存布局类似这样：

```cpp
struct MyClass {
    ObjectHeader header;
    
    struct Body { 
        T0 field0;
        T1 field1;
        T2 field2;
    
        // ...
    } body;
};
```

可以看到，Java 每个堆上对象的起始位置都有一个对象头，用于存储对象的类型、GC 辅助信息、锁相关信息等等，通常占 4~16 字节，随后便是它的字段。

对于值对象，如果我们想把他嵌入另一个对象中，我们可以选择直接将对象头删掉，直接把 `MyClass::Body` 这个结构体嵌入进来：。

比如对于这样一个类：

```java
class OtherClass {
    int intField;
    String stringField;
    MyClass myClassField;
}
```

如果 `MyClass` 变成了值类，那么它的内存布局可以优化成这样：

```cpp
struct OtherClass {
    ObjectHeader header;
    struct Body { 
        jint intField;
        java$lang$String *stringField;
        MyClass::Body myClassField;
    } body;
}
```

这种布局很容易实现，而且这种实现方式下，`MyClass` 不管是真正在堆上分配，还是被嵌入到其他对象内部，它的成员布局还是一致的，访问成员时只需要调整基址即可，生成的代码都能被复用。

### 熔化重组字段

直接去除对象头是一种简单的实现方式，但并不总是最高效的。JVM 可以将一个对象中包含的值对象的成员全部“熔化”，拆散成一个个的字段，然后再重新组织它们。

比如对于这样的代码：

```java
value record R0(String strValue, byte byteValue) {}
value record R1(Object objValue, short shortValue, R0 r0) {}
record R2(boolean boolValue, R1 r1) {}
```

对于上面的 `R2`，如果以无头对象的方式实现和 `R0` 和 `R1` ，它的布局可能是这样的：

```cpp
// 直接把 R0 和 R1 的布局嵌入进来
struct R2 {
    ObjectHeader header;
    
    struct {
        jboolean boolValue;
        struct {
            java$lang$Object *objValue;
            jshort shortValue;
            
            struct {
                java$lang$String *strValue;
                jbyte byteValue;
            } r0;
        } r1;
    } body;
};
```

这种实现方式直截了当，但是有一些问题。为了让程序在现代计算机上更高效，结构体的字段并不是紧凑排列的，而是会填充一些空位来对齐它们。

假设我们正在使用 64 位计算机，对象头的大小是 8 字节，Java 对象引用大小是 4 字节（得益于压缩指针技术，64 位 JVM 中的对象引用通常会被压缩到 32 位），那么它的实际布局会像这样：

```cpp
struct R2 {
    ObjectHeader header;        // 8 bytes
    
    jboolean boolValue;         // 1 byte
    // padding                  // 7 bytes
    java$lang$Object *objValue; // 4 bytes
    jshort shortValue;          // 2 bytes
    // padding                  // 2 bytes
    java$lang$String *strValue; // 4 bytes
    jbyte byteValue;            // 1 byte
    // padding                  // 3 bytes
};
```

那么一个 `R2` 对象的大小将为 32 字节。

而 JVM 可以选择另一种实现嵌入值对象的方式：把这些嵌套的值对象的字段全部拆散（熔化），由 JVM 自动重新排序它们，最后其布局可能会是这样：

```cpp
struct R2 {
    ObjectHeader header;        // 8 bytes
    
    java$lang$Object *objValue; // 4 bytes
    java$lang$String *strValue; // 4 bytes
    jboolean boolValue;         // 1 byte
    jbyte byteValue;            // 1 byte
    jshort shortValue;          // 2 bytes
    // padding                  // 4 bytes
};
```

这样的排序下，`R2` 对象的大小只有 24 字节。

这种实现方式具有两个优点：

1. 通过重排字段能够减少对齐填充，从而使对象结构更紧凑，减小内存占用，也能减轻 CPU 缓存压力，提升性能；
2. 重排字段时能够将 Java 对象引用排列在一起，使 GC 能更快的找到所有引用类型的字段。

### 交替分块数组

上面所有举的例子都使用普通的对象作为容器，没有提到数组。

对于数组来说，实现无头对象很容易，而想对值类型成员实现熔化重组，就要使用一种叫做**交替分块数组（alternating blocked array，简称 ABA）**的技术。

简而言之，我们可以把连续的几个值对象放在一起重排它们的字段。 

比如对于这样一个类：

```java
value record R(Object obj, long l) {}
```

我们可以把连续的四个 `R` 的实例放在一起组成一个块，并对它们的字段进行重排：

```cpp
struct R$Block4 {
    java$lang$Object *obj0, *obj1, *obj2, *obj3;
    jlong l0, l1, l2, l3;
}
```

这样原本每个 `R` 实例在数组中的大小是 16 字节，四个就要占用 64 字节，但像上面这样重排后就只需要 48 字节。

交替分块数组除了更紧凑（对于一些支持 `null` 元素的数组来说尤为重要）外，它还能把相关的数据排布到一起，这能够使一些处理数组成员的某个字段的代码更快速（可以看看[这个示例](https://cr.openjdk.org/~jrose/values/ab_array_code.txt)）。

### 堆上分配

除了上面所说的这些方案，值对象还有有一种非常简单的实现方案：像普通对象一样直接在堆上分配它，所有该类型的字段全部保存对这个堆上对象的引用（指针）。

由于值对象只是一种受到的约束更严格、功能更少的对象，直接在堆上分配它没有任何问题。

当然，采用这种方案的时候，我们享受不了多少值类型的优点，但这种实现方案很简单，不需要额外手段来支持 `null` 和维护一致性，对于现有代码不会发生意料之外的性能变化，这是一个缓慢但是有效的后备方案。JVM 解释器模式下可能会选择此方案，而 JIT 模式下，JVM 也可能会直接在堆上分配一些很大的值对象，从而避免传递时产生意外的巨大复制开销。 

