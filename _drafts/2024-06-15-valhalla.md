---
title: 'Java 值对象的堆上布局'
date: 2024-06-15 10:37:14
tags:
  - JVM
  - Valhalla
categories: blog
description: ''
---

OpenJDK 的 Project Valhalla 正在将值类型引入 Java，通过允许用户声明值类（value class），使 JVM 能够更自由的排布对象。这篇文章将会介绍 Valhalla 中的值对象在堆上的布局方案。

## 值类

在介绍值对象的布局之前，先让我快速给介绍一下 Valhalla 中的值类。如果你对 Valhalla 已经有所了解，可以跳过这一小节。

Valhalla 中的值类是以 `value` 这个上下文关键字所修饰的类：

```java
public value class MyClass {
  // ...
}
```

值类的实例就是值对象，它们的主要特点在于：

* 所有字段都必须是 `final` 的；
* 不支持通过 `synchronized` 对值对象进行加锁；
* `==` 对于值对象来说不再是比较引用，而是递归的对于所有字段应用 `==`；
* `System.identityHashCode` 对于值对象会基于它的字段进行计算，字段值完全相同的值对象的 `identityHashCode` 也完全一致；
* 无法对它们使用 `java.lang.ref` 包中的工具（比如 `WeakReference`）。

因为这些特点，JVM 能够更自由的排布对象，减少装箱，从而优化性能内存占用。

## 主要难题

在 JVM 为在堆上的值对象优化内存布局时，有两个问题我们需要特别考虑：字段撕裂和 `null`。

### 字段撕裂

什么是字段撕裂呢？看看这段代码：

```java
public record Pair(long v0, long v1) {}

public class MyClass {
    Pair pair = new Pair(0L, 0L);
}

var c = new MyClass();
new Thread(() -> c.pair = new Pair(10L, 20L)).start();
System.out.println("c.pair = " + c.pair);

```

上面的代码中，`Pair` 拥有两个字段，但即便是在另一个线程中修改 `MyClass.pair` 这个字段，我们也能保证它要么是 `[0, 0]`，要么是 `[10, 20]`。

对于引用类型来说，这是自然而然的，毕竟 `MyClass.pair` 这个字段只是一个引用，或者说是一个指针。我们先在线程本地构造了一个包含新值的对象，这一步不涉及多线程，非常安全；随后我们去更新 `MyClass.pair` 这个字段中存储的指针值，这个过程是原子的，另一个线程中观察到的要么是旧对象的地址，要么是新对象的地址，不可能出现一个损坏的对象，所以也很安全。

但是如果 `Pair` 是一个值类型，那么这件事就不这么简单了。

如果 `Pair` 是值类型，那么我们可能会期望上面的代码被优化成这样：

```java
public class MyClass {
    long pair$v0 = 0L;
    long pair$v1 = 0L;
}

var c = new MyClass();
new Thread(() -> { 
    c.pair$v0 = 10L;
    c.pair$v1 = 10L;
}).start();
System.out.println("c.pair = " + c.pair);
```

但如果真的这样实现那问题就来了，因为给 `c.pair$v0` 和 `c.pair$v1` 的赋值变成了两步。假如我们刚好在 `c.pair$v0 = 10L` 与 `c.pair$v1 = 10L` 这两句之间去观察 `c.pair`，那么它的值可能是 `[10, 0]`，这不是任何我们通过 `new Pair(...)` 创建出来的对象，所以这里就发生了字段撕裂。

一直以来 JVM 都会

### 

## 基本方案

位于堆上的值对象可能是另一个对象的字段成员，也可能是数组中的元素，我们在这里要考虑的事这些值对象在嵌入它的父级（也就是包含值对象字段的对象，或者元素是值对象的数组）时是如何排布的。





