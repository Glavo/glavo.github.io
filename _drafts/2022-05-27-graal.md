---
title: GraalVM
date: 2022-05-27 22:00:00
tags:
- JVM
- GraalVM
-JIT
- AOT
categories: blog
description: GraalVM
---

Java 当然可以实现 Java，并且现在不仅仅停留在“可以”上，我们现在已经有了一个现实的实现——[GraalVM](https://www.graalvm.org/)。

超出很多人认知的是，GraalVM 中不仅仅用 Java 实现了 Java 的 JIT/AOT 编译器，**而且还用 Java 实现了内存管理、GC 等底层功能。**

之前我也简单说过这件事，那么今天我会带着各位一步步地理解 GraalVM 的原理，详细地解释 GraalVM 是怎么做到这样令人惊叹的事情，希望能够帮助各位明白它是如何工作的。

（这里可能会重复（但更详细）地讲述一部分我曾经说过的东西，所以请善用目录功能跳转到自己感兴趣的位置）

## 从编译器说起

学习过编译原理的朋友应该对编译器的运作原理非常清楚，但我还是见到过很多人对此抱有疑虑，认为实现编译器必须要用 C/C++ 这样贴近底层的本机语言才能实现。
我觉得有必要简略地介绍一下编译器的运作原理，这样才能理解 GraalVM 是如何运作的。

对于编译器，我们可以抽象出这样一个最小功能接口：

```java
interface Compiler {
    byte[] compile(String code);
}
```

事实上，编译器就是这样的一个东西：接受代码，并将其转换为一串字节。

所以，任何能够进行字符串操作的语言，都可以实现编译器。理论上我们完全可以用 Python 重新实现一遍 LLVM 和 Clang，而用这个 Python 实现的 Clang 编译 C++ 代码的结果与原版的 Clang 编译的不会有半点区别，性能完全一致。

譬如，这里我用 Java 实现一个超级简单的编译器，将一小段字符串编译为 X86 机器码：

```java
public class MyCompiler implements Compiler {
    public byte[] compile(String code) {
        if (code.startsWith("const ")) {
            int value = Integer.parseInt(code.substring("const ".length()));

            byte b1 = (byte) (value >>>  0);
            byte b2 = (byte) (value >>>  8);
            byte b3 = (byte) (value >>> 16);
            byte b4 = (byte) (value >>> 24);

            return new byte[]{
                (byte) 0xb8, b1, b2, b3, b4,    // movl    $value, %eax
                (byte) 0xc3                     // retq
            };
        }
        throw new UnsupportedOperationException();
    }
}
```

对于这个编译器，我们可以调用它编译一小段代码到 X86 机器码：

```java
byte[] machineCode = new MyCompiler().compile("const 233");
```

现在，我们的 `machineCode` 中包含了一个函数，其功能等价于 C 函数

```C
int fun() { return 233; }
```

这个 `233` 就是我们传递的常数，你可以任意修改它。

拿到了这样的一串机器码后，我们可以把它包装成 ELF 或者 PE 格式，写入一个 `.so` 或者 `.dll` 文件中，然后我们就可以在程序中调用这个函数了！这就是我们常说的 AOT （Ahead-of-time） 编译，静态地将代码编译为机器码并写入可执行文件/共享库中。这也就是 C/C++/Rust 等语言常见编译器的工作原理。

除此之外，我们也可以不把它写入到文件内。现代操作系统大多支持我们申请一段可执行的内存（Windows 上可以通过 `VirtualAlloc` 和 `VirtualProtect` 函数实现）。所以，我们可以把 `machineCode` 直接写入可执行的内存，把内存地址强制转换成一个 `int (*)()` 函数指针，这样我们就可以直接在当前进程里调用它了！

我用纯 Java 实现过一个最简的样例，展示了如何调用系统 API 来执行运行时生成的机器码：https://gist.github.com/Glavo/aabbac7f206c56beeacd711c4726e260

这样的做法被我们称之为 JIT （Just-In-Time）编译：在运行时把一段代码编译为机器码。目前 Java、C# 等语言都依赖 JIT 在运行时将中间代码编译为机器码，从而得到接近本机语言级别的性能。

从这些样例里应该很容易看出来，**生成的机器码和用来实现编译器的语言无关**，我们可以用任何支持字符串操作的语言（C、Java、Python 甚至 Bash）编译出一模一样的结果，有着完全一致的性能。

## JVMCI 接口

在 OpenJDK 9 中，JVM 引入了 Java 语言级的 JVMCI (JVM Compiler Interface) 接口，核心是这样的一个接口：

```java
public interface JVMCICompiler {
    CompilationRequestResult compileMethod(CompilationRequest request);
}
```

是不是和上一节 `Compiler` 接口很像？不过上一节的接口只是玩具级别的，现实中的编译器远比此复杂，所以 JVMCI 接口中的 `compileMethod` 方法接受的参数和返回的结果都附带有更多信息，包括对内联的建议、Profiling 数据等等。

引入这个接口后，第三方可以通过实现它提供自己的 JIT 编译器代替 HotSpot 自带的 C2 编译器，这也是 Graal 的基础之一。